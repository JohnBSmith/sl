
use std::f64::NAN;
use std::f64::consts::{PI};

const GAMMA: f64 = 0.57721566490153286061;

fn hf(x: f64) -> f64 {
    let xm1 = 1.0/x;
    let xm2 = xm1*xm1;
    let xm4 = xm2*xm2;
    let xm6 = xm4*xm2;
    let xm8 = xm6*xm2;
    let xm10 = xm8*xm2;
    let xm12 = xm10*xm2;
    let xm14 = xm12*xm2;
    let xm16 = xm14*xm2;
    let xm18 = xm16*xm2;
    let xm20 = xm18*xm2;
    return xm1*(1.0
        +7.44437068161936700618E2*xm2
        +1.96396372895146869801E5*xm4+
        2.37750310125431834034E7*xm6
        +1.43073403821274636888E9*xm8
        +4.33736238870432522765E10*xm10
        +6.40533830574022022911E11*xm12
        +4.20968180571076940208E12*xm14
        +1.00795182980368574617E13*xm16
        +4.94816688199951963482E12*xm18
        -4.94701168645415959931E11*xm20
    )/(
        1.0+7.46437068161927678031E2*xm2
        +1.97865247031583951450E5*xm4
        +2.41535670165126845144E7*xm6
        +1.47478952192985464958E9*xm8
        +4.58595115847765779830E10*xm10
        +7.08501308149515401563E11*xm12
        +5.06084464593475076774E12*xm14
        +1.43468549171581016479E13*xm16
        +1.11535493509914254097E13*xm18
    );
}

fn hg(x: f64) -> f64 {
    let xm1 = 1.0/x;
    let xm2 = xm1*xm1;
    let xm4 = xm2*xm2;
    let xm6 = xm4*xm2;
    let xm8 = xm6*xm2;
    let xm10 = xm8*xm2;
    let xm12 = xm10*xm2;
    let xm14 = xm12*xm2;
    let xm16 = xm14*xm2;
    let xm18 = xm16*xm2;
    let xm20 = xm18*xm2;
    return xm2*(1.0
        +8.1359520115168615E2*xm2
        +2.35239181626478200E5*xm4
        +3.12557570795778731E7*xm6
        +2.06297595146763354E9*xm8
        +6.83052205423625007E10*xm10
        +1.09049528450362786E12*xm12
        +7.57664583257834349E12*xm14
        +1.81004487464664575E13*xm16
        +6.43291613143049485E12*xm18
        -1.36517137670871689E12*xm20
    )/(1.0
        +8.19595201151451564E2*xm2
        +2.40036752835578777E5*xm4
        +3.26026661647090822E7*xm6
        +2.23355543278099360E9*xm8
        +7.87465017341829930E10*xm10
        +1.39866710696414565E12*xm12
        +1.17164723371736605E13*xm14
        +4.01839087307656620E13*xm16
        +3.99653257887490811E13*xm18
    );
}

#[allow(non_snake_case)]
fn Si4(x: f64) -> f64 {
    let x2 = x*x;
    let x4 = x2*x2;
    let x6 = x4*x2;
    let x8 = x6*x2;
    let x10 = x8*x2;
    let x12 = x10*x2;
    let x14 = x12*x2;
    return x*(1.0
        -4.54393409816329991E-2*x2
        +1.15457225751016682E-3*x4
        -1.41018536821330254E-5*x6
        +9.43280809438713025E-8*x8
        -3.53201978997168357E-10*x10
        +7.08240282274875911E-13*x12
        -6.05338212010422477E-16*x14
    )/(1.0
        +1.01162145739225565E-2*x2
        +4.99175116169755106E-5*x4
        +1.55654986308745614E-7*x6
        +3.28067571055789734E-10*x8
        +4.5049097575386581E-13*x10
        +3.21107051193712168E-16*x12
    );
}

#[allow(non_snake_case)]
fn Ci4(x: f64) -> f64 {
    let x2 = x*x;
    let x4 = x2*x2;
    let x6 = x4*x2;
    let x8 = x6*x2;
    let x10 = x8*x2;
    let x12 = x10*x2;
    let x14 = x12*x2;
    return GAMMA+x.ln()+x2*(-0.25
        +7.51851524438898291E-3*x2
        -1.27528342240267686E-4*x4
        +1.05297363846239184E-6*x6
        -4.68889508144848019E-9*x8
        +1.06480802891189243E-11*x10
        -9.93728488857585407E-15*x12
    )/(1.0
        +1.1592605689110735E-2*x2
        +6.72126800814254432E-5*x4
        +2.55533277086129636E-7*x6
        +6.97071295760958946E-10*x8
        +1.38536352772778619E-12*x10
        +1.89106054713059759E-15*x12
        +1.39759616731376855E-18*x14
    );
}

#[allow(non_snake_case)]
pub fn Si(x: f64) -> f64 {
    let s = x.signum();
    let x = x.abs();
    if x<4.0 {
        return s*Si4(x);
    }else{
        return s*(0.5*PI-hf(x)*x.cos()-hg(x)*x.sin());
    }
}

#[allow(non_snake_case)]
pub fn Ci(x: f64) -> f64 {
    if x<=0.0 {
        return NAN;
    }else if x<4.0 {
        return Ci4(x);
    }else{
        return hf(x)*x.sin()-hg(x)*x.cos();
    }
}


